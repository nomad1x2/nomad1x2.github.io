<!DOCTYPE HTML>
<html>
	<head>
		<title>nomad - cybersecurity</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<script defer src="../../assets/prism/prism.js"></script>
	</head>
	<body class="writeup">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../index.html" class="logo"><strong>nomad</strong> - cybersecurity</a>
									
									<ul class="icons">
										<li><a href="https://github.com/nomad1x2" class="icon brands fa-github"><span class="label">Github</span></a></li>
									</ul>
									
								</header>

							<!-- Content -->
								<section>
									<header class="main">
										<h2>Task 6 - It's always DNS - (Reverse Engineering, Cryptography, Vulnerability Research, Exploitation)</h2>
									</header>
									<div class="box">
										<p>The recovered data indicates the APT is using a DNS server as a part of their operation. The triage team easily got the server running but it seems to reply to every request with errors.</p>
										
										<p>You decide to review past SIGINT reporting on the APT. Why might the APT be targeting the Guardian Armaments JCTV firmware developers? Reporting suggests the APT has a history of procuring information including the location and movement of military personnel.</p>
										
										<p>Just then, your boss forwards you the latest status update from Barry at GA. They found code modifications which suggest additional DNS packets are being sent via the satellite modem. Those packets probably have location data encoded in them and would be sent to the APT.</p>
										
										<p>This has serious implications for national security! GA is already working on a patch for the firmware, but the infected version has been deployed for months on many vehicles.</p>
										
										<p>The Director of the NSA (DIRNSA) will have to brief the President on an issue this important. DIRNSA will want options for how we can mitigate the damage.</p>
										
										<p>If you can figure out how the DNS server really works maybe we will have a chance of disrupting the operation.</p>
										
										<p><b>Find an example of a domain name (ie. foo.example.com.) that the DNS server will handle and respond with NOERROR and at least 1 answer.</b></p>
										
										<p><b>Prompt:</b><br><li>Enter a domain name which results in a NOERROR response. It should end with a '.' (period)</li></p>
									</div>

									<hr class="major" />
									
									
									
									
									
									<!-- Work -->							
									<h3>Solving the task:</h3>
									
									<p>This one stumped me almost as long as task 3 did, but it became my favorite task by far.</p>
									
									<p>As we saw from the previous task, we end up with three files from the USB:</p>
									
									<li><b>Coredns</b> - which is a stripped <a href="https://coredns.io/">Coredns</a> binary written in Go</li>

									<li><b>Corefile</b> - the Coredns config file</li>

									<li><b>microservice</b> - another stripped binary (referencing JS, so assumed JS)</li>
									<br>
									<p>The makeup of the Corefile gives us a very specific regex that we are going for:</p>
									
<!-- Code emulation -->	
<div class="box">						
<h4>Corefile:</h4>
<pre><code class="language-go">.:1053 {
  acl {
    allow type A
    filter
  }
  view firewall {
    expr type() == 'A' && name() matches '^x[^.]{62}\\.x[^.]{62}\\.x[^.]{62}\\.net-zghn2ybn\\.example\\.com\\.$'
  }
  log
  cache 3600
  errors
  frontend
}
</pre></code>
</div>
									
									<p>From my research, I found that Coredns uses a chain of 'plugins' and loads the <a href="https://coredns.io/2017/07/23/corefile-explained/">Corefile</a> for its configuration which includes those plugins. Based on the task and the Corefile, we are looking for a domain that is of <a href="https://support.dnsimple.com/articles/a-record/#whats-an-a-record">record type A</a>, provides a <a href="https://bluecatnetworks.com/blog/the-top-four-dns-response-codes-and-what-they-mean/">NOERROR</a> response, <b>and</b> matches this regex:<br><br><b>x[62 characters].x[62 characters].x[62 characters].net-zghn2ybn.example.com.</b></p>
									
									<p>Seems straight forward: find the domain -- but what is that microservice?.. We'll get back to that.</p>
									
									<p>From my CoreDNS research, I also found that there is a <a href="https://coredns.io/plugins/debug/">debug</a> plugin that gives more logging details (similar to Task 3's loglevel). I just needed to add it to the Corefile, run the DNS server, and then generate a DNS query:</p>
									
									<p><em>Note: The dig and response lines were one line, but I had to edit the formatting to not mess with the rest of the site formatting.</em></p>
													
<!-- Terminal emulation -->	
<div class="box">
<h4>DNS query:</h4>					
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ dig @localhost -p 1053 xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz. xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.net-zghn2ybn.example.com.

;; communications error to 127.0.0.1#1053: timed out
;; communications error to 127.0.0.1#1053: timed out
;; communications error to 127.0.0.1#1053: timed out

; <<>> DiG 9.18.33-1~deb12u2-Debian <<>> @localhost -p 1053 xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz. xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.net-zghn2ybn.example.com.

; (1 server found)
;; global options: +cmd
;; no servers could be reached
</pre>
<h4>CoreDNS log:</h4>					
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ ./coredns
.:1053
CoreDNS-1.11.3
linux/amd64, go1.21.8, a7ed346-dirty

[DEBUG] plugin/frontend: type: 1

[ERROR] plugin/frontend: error decoding input:
xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz. xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.net-zghn2ybn.example.com. as:

ABCDEFGHIJKLMNOPQRSTUVW=0123456789ABCDEFGHIJKLMNOPQRSTUVW=ABCDEFGHIJKLMNOPQRSTUVW=0123456789ABCDEFGHIJKLMNOPQRSTUVW= ABCDEFGHIJKLMNOPQRSTUVW=0123456789ABCDEFGHIJKLMNOPQRSTUVW=

[DEBUG] plugin/frontend: bad name: illegal base32 data at input byte 22

[INFO] 127.0.0.1:34062 - 50384 "A IN xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz. xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.net-zghn2ybn.example.com. udp 257 false 1232" NXDOMAIN qr,aa,rd 464 0.0008625s

[INFO] 127.0.0.1:38235 - 50384 "A IN xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz. xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.net-zghn2ybn.example.com. udp 257 false 1232" NXDOMAIN qr,aa,rd 464 0.0001546s

[INFO] 127.0.0.1:39560 - 50384 "A IN xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz. xabcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz.net-zghn2ybn.example.com. udp 257 false 1232" NXDOMAIN qr,aa,rd 464 0.0000717s
</pre>
</div>							
									<p>Here we get some pretty interesting data. The error we get in the CoreDNS log is <b>bad name: illegal base32 data at input byte 22</b>. The DNS server looks like it combines each subdomain into one string, and (with some trial and error) removes the <b>.'s, W's, X's, Y's, and top-level</b> and also <b>turns Z's into ='s</b>. With some more research, I found that this isn't traditional Base32 encoding, but instead <a href="https://www.rfc-editor.org/rfc/rfc4648.html#section-7">Base32 encoding with extended hex alphabet</a>, which is mainly used with DNS (go figure).</p>
									
									<p>I then found a <a href="https://cryptii.com/pipes/base32-to-hex">site</a> that does online RFC 4648 encoding and encoded this string to Base32Hex: <b>abcdefghijklmnopqrstuvwxyz0123456789</b> which gave this encoding: <b><span class="breakable">C5H66P35CPJMGQBADDM6QRJFE1ON4SRKELR7EU3PF8O32CHJ6GQJCDPO74======</span></b>.</p>
									
									<p>The next step was to query the DNS server once more and record the results -- but this time, I removed the length requirements by removing the entire <b>view firewall</b> block. Through more trial and error, I found out that the domain still needed to be three parts separated by '.x' while also changing the '=' to 'z'. Here is the new query followed by the results:</p>
									
<!-- Terminal emulation -->	
<div class="box">
<h4>DNS query:</h4>					
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ dig @localhost -p 1053 xC5H66P35CPJMGQBAD.xDM6QRJFE1ON4SRKELR7.xEU3PF8O32CHJ6GQJCDPO74zzzzzz.net-zghn2ybn.example.com.
;; communications error to 127.0.0.1#1053: timed out
;; communications error to 127.0.0.1#1053: timed out
;; communications error to 127.0.0.1#1053: timed out

; <<>> DiG 9.18.33-1~deb12u2-Debian <<>> @localhost -p 1053 xC5H66P35CPJMGQBAD.xDM6QRJFE1ON4SRKELR7.xEU3PF8O32CHJ6GQJCDPO74zzzzzz.net-zghn2ybn.example.com.
; (1 server found)
;; global options: +cmd
;; no servers could be reached
</pre>
<h4>CoreDNS log:</h4>					
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ ./coredns
.:1053
CoreDNS-1.11.3
linux/amd64, go1.21.8, a7ed346-dirty

[DEBUG] plugin/frontend: type: 1

[DEBUG] plugin/frontend: got data: 6162636465666768696a6b6c6d6e6f707172737475767778797a30313233343536373839

[DEBUG] plugin/frontend: bad decrypt: bad handshake

[INFO] 127.0.0.1:50271 - 55434 "A IN xc5h66p35cpjmgqbad.xdm6qrjfe1on4srkelr7.xeu3pf8o32chj6gqjcdpo74zzzzzz.net-zghn2ybn.example.com. udp 135 false 1232" NXDOMAIN qr,aa,rd 240 0.0066028s
[INFO] 127.0.0.1:49007 - 55434 "A IN xc5h66p35cpjmgqbad.xdm6qrjfe1on4srkelr7.xeu3pf8o32chj6gqjcdpo74zzzzzz.net-zghn2ybn.example.com. udp 135 false 1232" NXDOMAIN qr,aa,rd 240 0.0002721s
[INFO] 127.0.0.1:49887 - 55434 "A IN xc5h66p35cpjmgqbad.xdm6qrjfe1on4srkelr7.xeu3pf8o32chj6gqjcdpo74zzzzzz.net-zghn2ybn.example.com. udp 135 false 1232" NXDOMAIN qr,aa,rd 240 0.0001346s
</pre>
</div>							

									<p>Here we can see even more interesting data, which helped me understand even more about this DNS server: <b>the Base32Hex encoded string is some kind of encrypted data handshake</b>, identified by the <b>bad decrypt: bad handshake</b> line. Unfortunately this was the end of the road for the CoreDNS server at this point in time -- I wasn't too familiar with stripped Golang binaries and hit a breaking point. So I started looking at the microservice. (again, don't mind the timestamps... was a little late getting to the writeups):</p>
									
<!-- Terminal emulation -->	
<div class="box">						
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ ./microservice
<span class="red">{"t":"2025-03-01T04:18:36.623Z","l":"ERROR","m":"Failed to connect to MongoDB"}</span>
<span class="red">{"t":"2025-03-01T04:18:36.708Z","l":"ERROR","m":"Failed to connect to the database"}</span>
<span class="blue">{"t":"2025-03-01T04:18:36.708Z","l":"INFO","m":"Disconnected from MongoDB"}</span>
</pre>
</div>
									
									<p>Here we see the microservice looks like it attempts to connect to a <a href="https://www.mongodb.com/company/what-is-mongodb">MongoDB</a> instance.</p>
									
									<p>Seeing as we are dealing with a DNS server that handles encrypted data, a database server of some kind, and an APT who is targeting GPS location data from military vehicles -- I had a gut instinct on where this task was going. I just needed to finish setting up the playground. I also unknowingly did 75% of the work for Task 7 during this task, but I'll keep it in this task write up since these write ups are the process of <em>my</em> solves.</p>
									
									<p>I'll initiate a MongoDB instance with the default ports and then restart the microservice:</p>

<!-- Terminal emulation -->	
<div class="box">						
<h4>MongoDB:</h4>
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ sudo mongod
{"t":{"$date":"2025-03-01T17:18:53.267-05:00"},"s":"I",  "c":"NETWORK",  "id":22943,   "ctx":"listener","msg":"Connection accepted","attr":{"remote":"127.0.0.1:48866","uuid":{"uuid":{"$uuid":"357b4019-9ad8-4049-a528-6b9228f0ec71"}},"connectionId":1,"connectionCount":1}}
{"t":{"$date":"2025-03-01T17:18:53.288-05:00"},"s":"I",  "c":"NETWORK",  "id":51800,   "ctx":"conn1","msg":"client metadata","attr":{"remote":"127.0.0.1:48866","client":"conn1","negotiatedCompressors":[],"doc":{"driver":{"name":"nodejs","version":"6.8.0"},"platform":"Deno v1.45.4, LE","os":{"name":"linux","architecture":"x64","version":"5.15.167.4-microsoft-standard-WSL2","type":"Linux"},"env":{"container":{"runtime":"docker"}}}}}

{"t":{"$date":"2025-03-01T17:18:53.412-05:00"},"s":"I",  "c":"NETWORK",  "id":22943,   "ctx":"listener","msg":"Connection accepted","attr":{"remote":"127.0.0.1:48870","uuid":{"uuid":{"$uuid":"3f96e30a-bbfd-4888-8979-ed82821cc2b0"}},"connectionId":2,"connectionCount":2}}
{"t":{"$date":"2025-03-01T17:18:53.413-05:00"},"s":"I",  "c":"NETWORK",  "id":51800,   "ctx":"conn2","msg":"client metadata","attr":{"remote":"127.0.0.1:48870","client":"conn2","negotiatedCompressors":[],"doc":{"driver":{"name":"nodejs","version":"6.8.0"},"platform":"Deno v1.45.4, LE","os":{"name":"linux","architecture":"x64","version":"5.15.167.4-microsoft-standard-WSL2","type":"Linux"},"env":{"container":{"runtime":"docker"}}}}}
{"t":{"$date":"2025-03-01T17:18:53.433-05:00"},"s":"I",  "c":"NETWORK",  "id":6788700, "ctx":"conn2","msg":"Received first command on ingress connection since session start or auth handshake","attr":{"elapsedMillis":19}}
</pre>

<!--Maybe change to the linux environment rather than wsl?-->
<h4>Microservice:</h4>
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ ./microservice
<span class="blue">{"t":"2025-03-01T22:18:53.292Z","l":"INFO","m":"Connected to MongoDB"}</span>
<span class="blue">{"t":"2025-03-01T22:18:53.456Z","l":"INFO","m":"Server is running on port 3000"}</span>
<span class="blue">{"t":"2025-03-01T22:23:53.469Z","l":"INFO","m":"Maintenance task completed"}</span>
<span class="blue">{"t":"2025-03-01T22:28:53.455Z","l":"INFO","m":"Maintenance task completed"}</span>
</pre>
</div>

									<p>There are a few things to note based on the mongodb logs:</p>
									<li>The microservice connected to MongoDB from 127.0.0.1 using Node.js 6.8.0</li>
									<li>The microservice is running on port 3000</li>
									<li>The microservice performs a 'maintenance' task every 5 minutes after initialization</li>
									<br>
									<p>I did some more research into port 3000, and dug deeper into the binary to find that the microservice was also running <a href="https://expressjs.com/">Express.js</a>. From here, I was able to locate the webserver's routes (/event/insert and /event/test), which confirmed my gut instincts above.</p>
									
									<p>We were dealing with a form of <a href="https://www.dnsfilter.com/blog/dns-tunneling-malware">DNS tunneling</a> where the APT seemed to be sending GPS data via DNS packets from the vehicle's modem. These DNS packets appeared to be (in theory at the time) sent to our DNS server, which then sent traffic to the microservice, which ultimately stored our vehicle location in a MongoDB server.</p>
									
									<p>At this point, I would dissect the microservice even further to get it to successfully interact with the MongoDB server. I found exactly what data we needed to send the microservice (at localhost:3000) in order to send the location data to the MongoDB server.</p>
									
									<p>Because that was the 75% of Task 7 I mentioned earlier, I'll leave out the extra steps in this task. After I figured out the microservice, it was a struggle to find the next step. I was lost in the sauce like a calculator kid trying to do mental math.</p>
									
									<p>I took a week off from working on the challenge and allowed my brain to recoup any of the neurons I had left. I finally started looking into reverse engineering stripped binaries and found <a href="https://cujo.com/blog/reverse-engineering-go-binaries-with-ghidra/">this</a> amazing stripped Golang blog post which included a <a href="https://github.com/getCUJO/ThreatIntel/tree/master/Scripts/Ghidra">link</a> to some of their stripped Golang recovery scripts. This is how I was able to find a small detail in Ghidra that led me down the correct path.</p>
									
									<p>I tried to run the <a href="https://github.com/getCUJO/ThreatIntel/blob/master/Scripts/Ghidra/go_func.py">go_func.py</a> script to recover function names but kept getting an error that <b>no .gopclntab section was found</b>, yet I could clearly see in the Program Tree that the section was in fact there. I also found that the <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">magic numbers</a> were that of <a href="https://go.dev/src/debug/gosym/pclntab.go">Golang 1.20 (line 181 -- 0xfffffff1)</a>:</p>
									
									<div class="box">
										<div style="text-align: center;">
											<span class="image object">
												<img src="../../images/ghidra_pclntab.png" alt="" width="auto" class="other-img"/>
											</span>
										</div>
									</div>
									
									<p>Something felt off… I stared at it for a while, and then it hit me -- it had been right in front of me the whole time. The <b>.gopclntab</b> section <em>WAS</em> there, but with a sneaky typo: <b>.gopc1ntab</b>. That tiny swap -- an "l" turned into a "1" -- was enough to throw everything off; Another facepalming moment.</p>

									<p>So, I needed to modify the go_func.py script by changing the name of the section to <b>.gopc1ntab</b> and to also treat the identified magic number (<b>0xfffffff1</b>) as Golang 1.18 (used for 1.18 and above):</p>
									
									<p><em>Note: I also got rid of the unecessary lines in the code to clean up what I was working with.</em></p>

<!-- Code emulation -->	
<div class="box">						
<h4>Modified go_func.py:</h4>
<pre><code class="language-python">#Recover function names in stripped Go binaries.
#@author padorka@cujoai
#@category goscripts
#@keybinding 
#@menupath 
#@toolbar 

from ghidra.program.model.symbol.SourceType import *

pclntab_magic = ['\xf1\xff\xff\xff\x00\x00']

#Find the .gopclntab section
def getGopclntab():
    for block in getMemoryBlocks():
		# Change the l to 1 here:
        if block.getName() == ".gopc1ntab":
            start = block.getStart()
            end = block.getEnd()
            print "%s [start: 0x%x, end: 0x%x]" % (block.getName(), start.getOffset(), end.getOffset())
            return start
    print "No .gopclntab section found."
    return None

#Recover function names for Go versions 1.18 and above
def renameFunc118(start):
    ptrsize= getByte(start.add(7))
    if ptrsize == 8:
        nfunctab = getLong(start.add(8))
        textStart = getLong(start.add(8 + 2*ptrsize))
        offset = getLong(start.add(8 + 3*ptrsize))
        funcnametab = start.add(offset)
        offset = getLong(start.add(8 + 7*ptrsize))
    else:
        nfunctab = getInt(start.add(8))
        textStart = getInt(start.add(8 + 2*ptrsize))
        offset = getInt(start.add(8 + 3*ptrsize))
        funcnametab = start.add(offset)
        offset = getInt(start.add(8 + 7*ptrsize))
    functab = start.add(offset)

    p = functab
    functabFieldSize = 4
    for i in range (nfunctab):
        func_address = currentProgram.getAddressFactory().getAddress(hex(getInt(p)+textStart).rstrip("L"))
        p = p.add(functabFieldSize)
        funcdata_offset = getInt(p)
        p = p.add(functabFieldSize)
        name_pointer = functab.add(funcdata_offset + functabFieldSize)
        name_address = funcnametab.add(getInt(name_pointer))
        func_name = getDataAt(name_address)

        #Try to define function name string.
        if func_name is None:
            try:
                func_name = createAsciiString(name_address)
            except:
                print "ERROR: No name" 
                continue

        
        func = getFunctionAt(func_address)
        if func is not None:
            func_name_old = func.getName()
            func.setName(func_name.getValue().replace(" ", ""), USER_DEFINED)
            print "Function %s renamed as %s" % (func_name_old, func_name.getValue())
        else:
            func = createFunction(func_address, func_name.getValue())
            print "New function created: %s" % func_name

start = getGopclntab()

if start is not None:
    magic = getInt(start) & 0xffffffff
    if magic == 0xfffffff1:
        renameFunc118(start)
    else:
        print "WARNING: Unknown .gopclntab magic"
</pre></code>

<h4>Rerunning the code in Ghidra:</h4>
<pre><code class="language-python">New function created: ds "github.com/coredns/example.validatePublicKey"
New function created: ds "github.com/coredns/example.decrypt"
New function created: ds "github.com/coredns/example.hashProtocolName"
New function created: ds "github.com/coredns/example.blake2HkdfInterface"
New function created: ds "github.com/coredns/example.getHkdf"
New function created: ds "github.com/coredns/example.decryptWithAd"
New function created: ds "github.com/coredns/example.initializeSymmetric"
New function created: ds "github.com/coredns/example.mixKey"
New function created: ds "github.com/coredns/example.mixHash"
New function created: ds "github.com/coredns/example.decryptAndHash"
New function created: ds "github.com/coredns/example.split"
New function created: ds "github.com/coredns/example.initializeInitiator"
New function created: ds "github.com/coredns/example.initializeResponder"
New function created: ds "github.com/coredns/example.readMessageA"
New function created: ds "github.com/coredns/example.readMessageRegular"
New function created: ds "github.com/coredns/example.InitSession"
New function created: ds "github.com/coredns/example.RecvMessage"
New function created: ds "github.com/coredns/example.doForwardData"
New function created: ds "github.com/coredns/example.doForwardData.func1"
New function created: ds "github.com/coredns/example.name2buffer"
New function created: ds "github.com/coredns/example.Frontend.ServeDNS"
New function created: ds "github.com/coredns/example.Frontend.Name"
New function created: ds "github.com/coredns/example.NoiseRecv"
New function created: ds "github.com/coredns/example.init.0"
New function created: ds "github.com/coredns/example.setup"
New function created: ds "github.com/coredns/example.setup.func1"
New function created: ds "github.com/coredns/example.init"
New function created: ds "github.com/coredns/example.(*Frontend).Name"
New function created: ds "github.com/coredns/example.(*Frontend).ServeDNS"
New function created: ds "type:.eq.github.com/coredns/example.noisesession"
New function created: ds "main.main"
go_func.py> Finished!
</pre></code>
</div>

									<p>As we can see, we were able to obtain the original function names and further decompile our stripped binary. Just based on the function names we were able to recover, we can see that most of them had to do with the encryption. I ended up spending a lot of time looking in to the decompiled code of all of these functions and wrote out what I thought was the right pseudo-framework of function calls:</p>
									
<!-- Code emulation -->	
<div class="box">						
<pre><code class="language-markup">x[62].x[62].x[62] Query from client

|
|
V

Frontend.ServeDNS() {

- name2buffer() {
-- strip(xn--, x, y)
-- replace(z, =)
-- Base32.decode(Hexencoded(A-V, 0-9))
- }

- NoiseRecv() {
-- InitSession() {
-- -- initializeInitiator() {

-- -- -- initializeSymmetric() {
-- -- -- -- hashProtocolName() {
-- -- -- -- -- blake2sChecksum()
-- -- -- -- }
-- -- -- }
-- -- -- mixHash(x3 times, Noise_K, 25519_Ch, aChaPoly, _BLAKE2s) {
-- -- -- -- blake2sChecksum()
-- -- -- }
-- -- }

-- -- initializeResponder() {
-- -- -- initializeSymmetric() {
-- -- -- -- hashProtocolName() {
-- -- -- -- -- blake2sChecksum()
-- -- -- -- }
-- -- -- }
-- -- -- mixHash(x3 times, Noise_K, 25519_Ch, aChaPoly, _BLAKE2s) {
-- -- -- -- blake2sChecksum()
-- -- -- }
-- -- }

-- }

-- RecvMessage() {
-- -- readMessageA() {
-- -- -- validatePublicKey() 
-- -- -- mixHash(no other refs) {
-- -- -- -- blake2sChecksum()
-- -- -- }
-- -- -- curve25519.scalarMult()
-- -- -- mixKey() {
-- -- -- -- getHkdf(new Hkdf)
-- -- -- }
-- -- -- decryptAndHash() {
-- -- -- -- decryptWithAd() {
-- -- -- -- -- decrypt() {
-- -- -- -- -- -- chacha20poly1305_.Open()
-- -- -- -- -- }
-- -- -- -- }
-- -- -- -- mixHash(x3 times, Noise_K, 25519_Ch, aChaPoly, _BLAKE2s) {
-- -- -- -- -- blake2sChecksum()
-- -- -- -- }
-- -- -- }
-- -- -- split() {
-- -- -- -- getHkdf(new Hkdf)
-- -- -- }
-- -- }
-- -- readMessageRegular() {
-- -- -- decryptWithAd() {
-- -- -- -- decrypt() {
-- -- -- -- -- chacha20poly1305_.Open()
-- -- -- -- }
-- -- -- }
-- -- }

-- }

- }

|
|
V

- doForwardData(msgpack -> localhost:3000/event/insert)

}
</pre></code>
</div>

									
									<p>I ultimately found the next step by doing quite a bit of research, focusing on the NoiseRecv, init, and readMessage functions. This allowed me to find the <a href="https://noiseprotocol.org/noise.html">Noise Protocol Framework</a> which was what this DNS server was using -- specifically the Noise_K handshake, as identified by running strings on the CoreDNS binary and simply searching "noise":</p>
									
<!-- Terminal emulation -->	
<div class="box">						
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ strings coredns | grep "noise"
*frontend.noisesession
type:.eq.github.com/coredns/example.noisesession
github.com/coredns/example@v0.0.0-20200925060636-a998e071a3a3/K_noise.go
github.com/coredns/example@v0.0.0-20200925060636-a998e071a3a3/noise_api.go
</pre>
</div>
									
									<p>I then found a <a href="https://noiseexplorer.com/patterns/K/">beta website</a> to play around with this framework and design or explore different Noise handshake patterns. On the Noise_K handshake pattern page, there is important information about the type of vulnerability we are looking for:</p>
									
<!-- Code emulation -->	
<div class="box">						
<pre class="terminal">
<span class="blue">Handshake Pattern Analysis:</span>
The initiator is initialized with a pre-shared long-term static key,
which is assumed to be pre-authenticated out of band by the responder.

The responder is initialized with a pre-shared long-term static key,
which is assumed to be pre-authenticated out of band by the initiator.

<span class="blue">Message A show detailed analysis:</span>
Message A, sent by the initiator, benefits from receiver authentication
but is vulnerable to <em>Key Compromise Impersonation</em>. If the responder's
long-term private key has been compromised, this authentication can be
forged...
</pre>
</div>

									<p>At this point I knew that we needed to find the server's private key, since we know that this handshake pattern is vulnerable to <b>Key Compromise Impersonation</b>, and the server is our responder in this case. Luckily for us, the entire source code for this specific handshake written in Golang can be generated from the beta site mentioned above. Keeping in mind that the server is the <b>responder</b> and the <b>initiator</b> is the vehicle sending its coordinates, take a look at the InitSession function:</p>
									
<!-- Code emulation -->	
<div class="box">	
<h4>K.noise.go (InitSession):</h4>					
<pre><code class="language-go">func InitSession(initiator bool, prologue []byte, s keypair, rs [32]byte) noisesession {
	var session noisesession
	psk := emptyKey
	if initiator {
		session.hs = initializeInitiator(prologue, s, rs, psk)
	} else {
		session.hs = initializeResponder(prologue, s, rs, psk)
	}
	session.i = initiator
	session.mc = 0
	return session
}
</pre></code>
</div>
									
									<p>The initializeInitiator and initializeResponder functions both pass important data: A prologue (which I verified to be the same as the source code), a static key pair (s), and remote static public key (rs). Since our server is the <b>responder</b> in this case, and the responder is initialized with long-term static keys that are <b>pre-authenticated out of band</b>, then it is safe to assume that the initiator's public key must be known -- and must be hardcoded along with the responder's static key pair.</p>
									
									<p>I thought I would be able to break down the initializeResponder function to find the hard coded keys -- and I did this using the Ghidra Debugger application with built in <a href="https://www.sourceware.org/gdb/">GNU Debugger</a>. I located which register we needed to break at in order to find the data we needed -- finding the remote static public key (the initiator's public key) and the server's static key pair was fairly easy:</p>

									<div class="box">
										<h4>Remote static (initiator public key):</h4>
										<div style="text-align: center;">
											<img src="../../images/coredns_decompiled_rs.png" alt="" width="auto" class="other-img"/>
										</div>
									</div>
										<p>The remote static key was located at an offset of <b>0x1b8</b> from the stack pointer ($rsp + 0x1b8).</p>
									<div class="box">
										<h4>Static public key (responder public key):</h4>
										<div style="text-align: center;">
											<img src="../../images/coredns_decompiled_s_pub.png" alt="" width="auto" class="other-img"/>
										</div>
									</div>
										<p>The static public key was located at an offset of <b>0x178</b> from the stack pointer ($rsp + 0x178).</p>

<!-- Terminal emulation -->	
<div class="box">
<h4>GDB breakdown:</h4>				
<pre class="terminal">
(gdb) b *0x01d85e20
Breakpoint 1 at <span class="blue">0x1d85e20</span>
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

--[Send a query to break]--

Thread 12 "coredns" hit Breakpoint 1, <span class="blue">0x0000000001d85e20</span> in ?? ()

(gdb) x/32xb $rsp + 0x1b8
<span class="blue">0xc000714178</span>:   0xce    0xb7    0x10    0x00    0xc7    0xe0    0xde    0x7c
<span class="blue">0xc000714180</span>:   0xb9    0x79    0xb8    0x71    0xc0    0xaa    0xa2    0x4e
<span class="blue">0xc000714188</span>:   0xd2    0x5d    0xef    0xf9    0x13    0xec    0xd1    0x26
<span class="blue">0xc000714190</span>:   0x68    0xc4    0x37    0x4f    0xf3    0x8e    0x03    0x41

(gdb) x/32xb $rsp + 0x178
<span class="blue">0xc000714138</span>:   0x93    0x77    0x65    0xbc    0x56    0x15    0x62    0xf6
<span class="blue">0xc000714140</span>:   0x58    0x09    0xce    0xcd    0x24    0xf9    0xff    0x22
<span class="blue">0xc000714148</span>:   0x1b    0xd1    0x3d    0x92    0x4c    0x54    0x32    0x95
<span class="blue">0xc000714150</span>:   0x21    0x49    0x7e    0x0a    0x16    0x9d    0xab    0x5d
</pre>
<p>The initiator's public key that the server is expecting is: <b>ce b7 10 00 c7 e0 de 7c b9 79 b8 71 c0 aa a2 4e d2 5d ef f9 13 ec d1 26 68 c4 37 4f f3 8e 03 41</b>.</p>			
<p>The server's public key is: <b>93 77 65 bc 56 15 62 f6 58 09 ce cd 24 f9 ff 22 1b d1 3d 92 4c 54 32 95 21 49 7e 0a 16 9d ab 5d</b>.</p>			
</div>

									<p>I took a somewhat different approach (lucky maybe?) to find the server's private key. I searched the memory for the server public key bytes where I also found the initiator's public key to be somewhat adjacent. There was exactly 32 bytes in between the server's public key and the peer's public key, and I figured that must have been the server's private key (which is why I got kind of lucky):</p>
									
									<div class="box">
										<div style="text-align: center;">
											<img src="../../images/coredns_decompiled_priv.png" alt="" width="auto" class="other-img"/>
										</div>
									</div>
									
									<p>The server's private key is: <b>41 53 b5 25 5f 55 52 52 86 48 73 04 b5 4a f3 f2 85 65 72 25 a6 e4 5b 5a a3 a6 5a 91 26 dc 6b 55</b>. I even used the <b>K.noise.go</b>'s generatePublicKey function to verify this:</p>
																		
<!-- Code emulation -->	
<div class="box">	
<h4>K.noise.go (generatePublicKey):</h4>					
<pre><code class="language-go">func generatePublicKey(private_key [32]byte) [32]byte {
	var public_key [32]byte
	curve25519.ScalarBaseMult(&public_key, &private_key)
	return public_key
}

func main() {
	
	serverPrivateKey := [32]byte{0x41, 0x53, 0xb5, 0x25, 0x5f, 0x55, 0x52, 0x52, 0x86, 0x48, 0x73, 0x04, 0xb5, 0x4a, 0xf3, 0xf2, 0x85, 0x65, 0x72, 0x25, 0xa6, 0xe4, 0x5b, 0x5a, 0xa3, 0xa6, 0x5a, 0x91, 0x26, 0xdc, 0x6b, 0x55}
	
	fmt.Printf("%x\n", generatePublicKey(serverPrivateKey))
	
}
</pre></code>

<h4>Running K.noise.go:</h4>				
<pre class="terminal">
<span class="greentitle">nomad@LAPTOP-7SLS1EV9</span>:<span class="blue">~</span>$ go run K.noise.go
937765bc561562f65809cecd24f9ff221bd13d924c54329521497e0a169dab5d
</pre>	
</div>									

									<p>As we can see, the public key generated from the 32 bytes we found is the same as the responder's public key -- so we can confirm that the bytes we found are in fact the responder's private key. The next step was to find the prologue which took a little bit more source code analysis. Looking at the <b>mixHash</b> function, it called another function which returned 32 bytes (<b>getHash</b>):</p>

<!-- Code emulation -->	
<div class="box">	
<h4>K.noise.go (mixHash/getHash):</h4>					
<pre><code class="language-go">func getHash(a []byte, b []byte) [32]byte {
	return blake2s.Sum256(append(a, b...))
}

func mixHash(ss *symmetricstate, data []byte) *symmetricstate {
	ss.h = getHash(ss.h[:], data)
	return ss
}
</pre></code>
</div>

									<p>This verifies that we were looking for another 32-byte string after the hashing. Looking back at our decompiled code in Ghidra, we see that the first, second, and third arguments are stored in param_33, param_34, and param_35 respectively. Because we are working with on x86-64, we know that the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">first three integer or pointer arguments are passed in registers RDI, RSI, and RDX</a>. I looked in each register to see if there was anything that stood out:</p>

<!-- Terminal emulation -->	
<div class="box">
<h4>GDB breakdown:</h4>				
<pre class="terminal">(gdb) info reg
...
rdx            0xc00072bf88        824641240968
rsi            0xffffffffffffffff  -1
rdi            0x20                32
...
</pre>	
<p>Here we see that RDX is pointing to the memory address of <b>0xc00072bf88</b>, which we can further dissect to find our 32-byte prologue:</p>
<pre class="terminal">(gdb) x/32xb $rdx
<span class="blue">0xc00072bf88</span>:   0x92    0x11    0x37    0xde    0xca    0x1d    0x7b    0xb6
<span class="blue">0xc00072bf90</span>:   0x34    0xbd    0xe1    0x47    0xfe    0xe6    0x81    0x30
<span class="blue">0xc00072bf98</span>:   0xe7    0x04    0x6f    0x34    0x34    0x67    0xb4    0x6b
<span class="blue">0xc00072bfa0</span>:   0x3d    0x39    0x19    0x0c    0x7a    0x50    0x1d    0x09
</pre>	
</div>

									<p>And there is the prologue. This was the Noise_K information I was working with up until this point:</p>
									<li>
										The responder's private key: <b>41 53 b5 25 5f 55 52 52 86 48 73 04 b5 4a f3 f2 85 65 72 25 a6 e4 5b 5a a3 a6 5a 91 26 dc 6b 55</b>
									</li>
									<li>
										The responder's public key: <b>93 77 65 bc 56 15 62 f6 58 09 ce cd 24 f9 ff 22 1b d1 3d 92 4c 54 32 95 21 49 7e 0a 16 9d ab 5d</b>		
									</li>
									<li>
										The initiator's public key: <b>ce b7 10 00 c7 e0 de 7c b9 79 b8 71 c0 aa a2 4e d2 5d ef f9 13 ec d1 26 68 c4 37 4f f3 8e 03 41</b>
									</li>
									<li>
										The prologue: <b>92 11 37 de ca 1d 7b b6 0x34 bd e1 47 fe e6 81 30 0xe7 04 6f 34 34 67 b4 6b 0x3d 39 19 0c 7a 50 1d 09</b>
									</li>
				
									<p><br></p>

									<hr class="major" />
									
									<!--Solution-->
									<div id="solution">
										<h3>The solution:</h3>
									</div>
									
									<p>In progress</P>
									<!--response":"That didn't work."-->
									<hr class="major" />





									
									<div class="box">
										<div style="text-align: center;">
											<p><b>Great job!</b></p>
											<span class="image object">
												<img src="../../images/badge6.png" alt="" class="badge-img"/>
											</span>
										</div>
									</div>
									
									
									
									
									<!--Pages-->
									<div style="text-align: center;">
										<ul class="pagination">
											<li><a href="Task5.html" class="button">Prev</a></li>
											<li><a href="Task1.html" class="page">1</a></li>
											<li><a href="Task2.html" class="page">2</a></li>
											<li><a href="Task3.html" class="page">3</a></li>
											<li><a href="Task4.html" class="page">4</a></li>
											<li><a href="Task5.html" class="page">5</a></li>
											<li><a href="#" class="page active">6</a></li>
											<li><a href="Task7.html" class="page">7</a></li>
											<li><a href="Task7.html" class="button">Next</a></li>
										</ul>
									</div>
									
									
									
									
								</section>

						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">

							<!-- Search -->
								<section id="search" class="alt">
									<form method="post" action="#">
										<input type="text" name="query" id="query" placeholder="Search" />
									</form>
								</section>

							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
										<li><a href="../NSACodebreaker2024.html">Challenge Home</a></li>
										<li>
											<span class="opener">Task list</span>
											<ul>
												<li><a href="Task1.html">Task1</a></li>
												<li><a href="Task2.html">Task2</a></li>
												<li><a href="Task3.html">Task3</a></li>
												<li><a href="Task4.html">Task4</a></li>
												<li><a href="Task5.html">Task5</a></li>
												<li><a href="#"><b>Task6</b></a></li>
												<li><a href="Task7.html">Task7</a></li>
											</ul>
										</li>
										<li><a href="#solution">The solution</a></li>
									</ul>
								</nav>

							<!-- Section -->
								<section>
									<header class="major">
										<h2>Get in touch</h2>
									</header>
									<ul class="contact">
										<li class="icon solid fa-envelope"><a href="#">nomad1x2sec@gmail.com</a></li>
									</ul>
								</section>

							<!-- Footer -->
								<footer id="footer">
									<!--<p class="copyright">&copy; Untitled. All rights reserved. Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>-->
									<p class="copyright">Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>

		<!-- Scripts??? -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/browser.min.js"></script>
			<script src="../../assets/js/breakpoints.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<script src="../../assets/js/main.js"></script>

	</body>
</html>